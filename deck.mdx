import { Appear, Image } from "mdx-deck";
import { Split, SplitRight } from "mdx-deck/layouts";
import { CodeSurfer } from "mdx-deck-code-surfer";
import { range } from "./helpers";

export { dark as theme } from "mdx-deck/themes";

# Async Testing

_"sprinkle some time on it"_

---

# Tests

- Quality
- Documentation

---

# Async can be difficult

- Time
- Learning curve
- Not intuitive

---

# Dealing with time

- Know the rules
- Control
- Simplify
- Observe

---

<CodeSurfer
  title="Knowledge is power"
  code={require("!raw-loader!./snippets/promises.js").default}
  lang="javascript"
  dark={false}
  steps={[
    { notes: "Promises follow a pre-defined rule set, the Promises/A+ spec" },
    {
      notes:
        "Promise callbacks are SCHEDULED when a promise settles (resolve/reject)."
    },
    {
      notes: `Then callbacks must execute in the order of they were SCHEDULED.`
    },
    {
      notes: "Let's see what ths looks like in our example"
    },
    {
      tokens: { 12: [0, 1, 2, 3] },
      notes: "Invoke our function generating promises"
    },
    {
      tokens: { 3: [4, 5, 6, 7, 8] },
      notes: "First promise is created and immediately resolved"
    },
    {
      lines: [4],
      notes: "First then callback is SCHEDULED, creating a new pending promise"
    },
    {
      lines: [5],
      tokens: { 3: [1, 2, 3] },
      notes: "Another then callback is QUEUED, but not yet scheduled"
    },
    {
      tokens: { 6: range(5, 4) },
      notes: "A second promise is created and immediately resolved"
    },
    {
      tokens: { 6: [1, 2, 3, ...range(13, 9)] },
      notes: "Second then callback is SCHEDULED, creating a new pending promise"
    },
    {
      lines: [7],
      notes:
        "Another then callback is queued, because the promise it depends on is yet to settle"
    },
    {
      lines: [9],
      notes: "The final promise depending on all our work is returned"
    },
    {
      tokens: { 12: range(14, 4) },
      notes: "The final then callback is QUEUED"
    },
    {
      tokens: { 4: range(10, 4) },
      notes: "The first callback executes, settling the promise"
    },
    {
      lines: [5],
      notes: "Next callback is QUEUED"
    },
    {
      tokens: { 6: range(12, 12) },
      notes: "Second callback is executed"
    },
    {
      tokens: { 5: range(10, 4) },
      notes: "Third callback executes, settling 'p1'"
    },
    {
      tokens: { 7: range(14, 5) },
      notes: "Callback attached to p1 can now be SCHEDULED"
    },
    {
      tokens: { 7: range(10, 8) },
      notes: "Callback executes as it's the only one scheduled"
    },
    {
      tokens: { 9: range(11, 3) },
      notes: "All work is complete, .all is settled"
    },
    {
      tokens: { 12: range(10, 7) },
      notes: "Final callback is SCHEDULED and executed"
    }
  ]}
/>

---

![](./resources/promises.png)

---

<CodeSurfer
  title="Practical application of the spec"
  code={require("!raw-loader!./snippets/use-the-spec.js").default}
  lang="javascript"
  dark={false}
  steps={[
    {
      notes:
        "Here is how this knowledge of the Promise spec can be applied in a test"
    },
    {
      lines: [35]
    },
    {
      range: [17, 28]
    },
    {
      lines: [36]
    },
    {
      lines: [9]
    },
    {
      lines: [38]
    },
    {
      range: [10, 12]
    },
    {
      lines: [39]
    }
  ]}
/>

---

<CodeSurfer
  title="Controling time"
  code={require("!raw-loader!./snippets/callback-refactor.js").default}
  lang="javascript"
  dark={false}
  steps={[
    {
      notes:
        "Promises are advanced, but built on top of basic primitives like callback functions"
    },
    {
      notes: "We can take advantage of this fact to make our code more testable"
    },
    { notes: "Step 1: Identify the callback function" },
    {
      tokens: { 8: [6, 7, 8, 9] },
      lines: [9, 10],
      notes: "Here it is, how is it invoked?"
    },
    {
      tokens: { 8: [1, 2, 3, 4, 5] },
      range: [6, 7],
      notes: "Through this promise chain"
    },
    {
      tokens: { 8: [1, 2, 3, 4, 5] },
      range: [6, 7],
      notes: "Let's see how simple primitves make existing code testable"
    }
  ]}
/>

---

<CodeSurfer
  title="Functions all the way down"
  code={require("!raw-loader!./snippets/callback-refactor-2.js").default}
  lang="javascript"
  dark={false}
  steps={[
    {
      range: [5, 7],
      notes: "Step 1: Wrap the service so that it uses callbacks"
    },
    { range: [4, 8], notes: "Step 2: Make it a prop" },
    { range: [12, 19], notes: "Step 3: Use the primitive callback pattern" },
    { range: [12, 19], notes: "Now let's see why it's easier to test" },
    { lines: [26], notes: "Simple functioins are simpler to mock" },
    {
      tokens: { 27: [7, 8, 9, 10, 11, 12, 13, 14, 15] },
      notes: "We can overwrite props"
    },
    { lines: [28], notes: "Now when we click..." },
    {
      tokens: { 26: [...Array(17).keys()].map(k => k + 8) },
      notes: "We removed time from the equation! (without breaking the API)"
    },
    {
      range: [16, 18],
      notes: "The callback is invoked immediately"
    },
    { lines: [29], notes: "And the test passes" }
  ]}
/>

---

<CodeSurfer
  title="Synchronous Data"
  code={require("!raw-loader!./snippets/sync-example.js").default}
  lang="javascript"
  dark={false}
  steps={[
    { notes: "How does this test behave?" },
    { lines: [31], notes: "Component mount" },
    { range: [13, 24], notes: "Initial render" },
    { lines: [32], notes: "Simulated event" },
    { lines: [6], notes: "Event handler" },
    { range: [7, 9], notes: "setState" },
    { range: [16, 20], notes: "Render, again" },
    { lines: [33], notes: "Assertion!" },
    { notes: "Success!" }
  ]}
/>

---

<Image src="./resources/better-than-expected.jpg" size="500px 385px" />

---

<CodeSurfer
  title="Async Data"
  code={require("!raw-loader!./snippets/async-example.js").default}
  lang="javascript"
  dark={false}
  steps={[
    { notes: "How does this test behave?" },
    { lines: [33], notes: "Component mount" },
    { range: [15, 26], notes: "Initial render" },
    { lines: [34], notes: "Simulated event" },
    { lines: [6], notes: "Event handler" },
    { tokens: { 7: [1, 2, 3] }, notes: "Data fetch" },
    { lines: [35], notes: "Assertion!" },
    { notes: "The test fails here... but" },
    { tokens: { 7: [4, 5, 6, 7, 8, 9, 10] }, notes: "The promise resolves" },
    { range: [8, 10], notes: "setState" },
    { range: [16, 23], notes: "Render, but no one is listening" },
    { notes: "..." }
  ]}
/>

---

<Image src="./resources/not-like-this.png" size="500px 385px" />
